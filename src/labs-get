#!/bin/bash 
# ------------------------------------------------------
#	labs-get v1.0.0-lx
#	Date Created: 12/25/2015
#	Date Edited: 12/30/2015
#	Copyright (C) 2015 Digital Warrior Labs
#	Author: Nathan Martindale (WildfireXIII)
# ------------------------------------------------------

declare -a g_workingArray
declare -a g_workingArray2
declare -a g_listDataArray
declare -a g_installedDataArray
declare -a g_dependenciesArray
declare -a g_tagsArray
declare -a g_filterArray
declare -a g_packageInstallArray
declare -a g_pkgInfoArray

g_workingData=""
g_workingBool=false
g_pkgInstallInstructions=""
g_pkgRemoveInstructions=""

# --------------------------- FUNCTIONS ------------------------------

# this function found from http://stackoverflow.com/questions/5031764/position-of-a-string-within-a-string-using-linux-shell-script
# ASSIGNS: g_workingData
function strindex()
{
	x="${1%%$2*}"
	[[ $x = $1 ]] && g_workingData=-1 || g_workingData=${#x}
}

# ASSIGNS: g_workingArray, g_listDataArray
function readListFile()
{
	unset g_workingArray
	i=0
	while read line; do
		if [[ $i -ne 0 ]]; then # dont' get the first line
			g_workingArray[$i]=$line
		fi
		((i++))
	done < $LIST_DATA_FILE
	g_listDataArray=("${g_workingArray[@]}")
}

# ASSIGNS: g_workingArray, g_installedDataArray
function readInstalledFile()
{
	unset g_workingArray
	i=0
	while read line; do
		if [[ $i -ne 0 ]]; then # don't get first line
			g_workingArray[$i]=$line 
		fi
		((i++))
	done < $INSTALLED_DATA_FILE
	g_installedDataArray=("${g_workingArray[@]}")
}

# ASSIGNS: g_workingArray, g_installedDataArray
function readTotalInstalledfile()
{
	unset g_workingArray
	i=0
	while read line; do
		g_workingArray[$i]=$line 
		((i++))
	done < $INSTALLED_DATA_FILE
	g_installedDataArray=("${g_workingArray[@]}")
}

# ASSIGNS: g_workingArray, g_pkgInfoArray
function readPkgDataFile() # assumes the package directory has already been pushed
{
	unset g_workingArray
	i=0
	while read line; do
		g_workingArray[$i]=$line
		((i++))
	done < "_PKG"
	g_pkgInfoArray=("${g_workingArray}")
}

# ASSIGNS: g_workingData
function getCSVCol() # pass in $1 as rowData, and $2 as colNum
{
	unset g_workingData
	IFS=',' read -ra Cols <<< "$1"
	g_workingData="${Cols[$2]}"
}

# ASSIGNS: g_workingArray
function getTagList() # $1 should be tag string
{
	unset g_workingArray
	IFS='|' read -ra Tags <<< "$1"
	g_workingArray=("${Tags[@]}")
}

# ASSIGNS: g_workingArray2
# REQUIRES: g_listDataArray or g_installedDataArray, g_filterArray
function filterPackageListByTags() # pass in $1 as true if installed, false if not
{
	#echo "uh, HELLO" # DEBUG
	newIndex=0
	unset g_workingArray2
	#echo "1:$1" # DEBUG
	if [[ "$1" = true ]]; then
		#echo "I'm a bug, and inside here even though I shouldnt' be.." # DEBUG
		for i in "${g_installedDataArray[@]}"
		do
			# fill tag array first
			unset g_workingArray
			getCSVCol "$i" 3 # assigns to g_workingData
			getTagList "$g_workingData" # assigns to g_workingArray
			g_tagsArray=("${g_workingArray[@]}")

			# check if should filter
			shouldFilter # assigns to g_workingBool
			if [[ "$g_workingBool" = false ]]; then
				g_workingArray2[$newIndex]="$i"
				((newIndex++))
			fi
		done
	else
		#echo "YO DAWG" # DEBUG
		for i in "${g_listDataArray[@]}"
		do
			#echo "line:$i" # DEBUG
			# fill tag array first
			unset g_workingArray
			getCSVCol "$i" 4 # assigns to g_workingData
			#echo "tags:$g_workingData" # DEBUG
			getTagList "$g_workingData" # assigns to g_workingArray
			g_tagsArray=("${g_workingArray[@]}")

			# check if should filter
			shouldFilter # assigns to g_workingBool
			if [[ "$g_workingBool" = false ]]; then
				g_workingArray2[$newIndex]="$i"
				#echo "is now: ${g_workingArray2[$newIndex]}" # DEBUG
				((newIndex++))
			fi
		done
	fi
}

# ASSIGNS: g_workingBool
# REQUIRES: g_tagsArray, g_filterArray
# sets g_workingBool to false if it should NOT filter, true if it should
function shouldFilter()
{
	tagFound=false
	negativeFilter=false

	# if no filter tags found, we're good
	if [[ "${g_filterArray[0]}" == "" ]]; then
		g_workingBool=false
		return
	fi
	
	for filter in "${g_filterArray[@]}"
	do
		# check for first letter is '!'
		negativeFilter=false
		#echo "first leter is ${filter:0:1}" # DEBUG
		if [[ "${filter:0:1}" == "!" ]]; then
			negativeFilter=true
			filter="${filter:1}"
			#echo "filter is now $filter" # DEBUG
		fi	

		# reset booleans
		tagFound=false

		for tag in "${g_tagsArray[@]}"
		do
			#echo "checking $filter with $tag" # DEBUG
			if [[ "$filter" == "$tag" ]];	then
				#echo "Found match!" # DEBUG
				tagFound=true	
				if [[ "$negativeFilter" = true ]]; then
					#echo "(but wasn't supposed to match)" # DEBUG
					g_workingBool=true
					#echo "returning false" # DEBUG
					return
				fi
			fi
		done

		if [[ "$tagFound" = false && "$negativeFilter" = false ]]; then
			g_workingBool=true
			return
		fi
	done

	# we've made it this far and haven't been disqualified so this one shouldn't be filtered!
	g_workingBool=false
}

# ASSIGNS: g_workingBool
function checkIfPackageInstalled() # $1 should be the name of the package
{
	unset g_workingBool
	readInstalledFile
	for installed in "${g_installedDataArray}"
	{
		getCSVCol "$installed" 0 # assigns to g_workingData
		if [[ "$g_workingData" == "$1" ]]; then
			g_workingBool=true
			return
		fi
	}
	g_workingBool=false
}

# REQUIRES: g_packageInstallArray
function installPackageList() # $1 should be boolean, whether to force install dependencies or not
{
	# unset package # just in case there's an issue with this?????? TODO TODO TODO check if this is necessary in bash
	for package in "${g_packageInstallArray[@]}"
	do
		checkIfPackageInstalled "$package"
		if [[ "$g_workingBool" = false ]]; then
			if [[ "$1" = true ]]; then
				labs-get -install $package -forceDependencies -noSpace
			else
				labs-get -install $package -noSpace
			fi
		else
			echo "Package '$package' was already installed, skipping..."
		fi
	done
}

# ASSIGNS: g_workingBool
# REQUIRES: g_tagsArray
function tagListContains() # $1 is tag name to search for
{
	unset g_workingBool
	for tag in "${g_tagArray[@]}"
	do
		if [[ "$tag" == "$1" ]]; then
			g_workingBool=true
			return
		fi
	done
	g_workingBool=false
}

function removePackageFromInstalled() # $1 is package name to remove
{
	readTotalInstalledFile
	rm $INSTALLED_DATA_FILE
	for installedPkg in "${g_installedDataArray[@]}"
	do
		getCSVCol "$installedPkg" 0
		analyzingPkg=$g_workingData
		if [[ "$1" -ne "$analyzingPkg" ]]; then
			echo "$installedPkg" >> $INSTALLED_DATA_FILE
		fi
	done
}

# checks _PKG info to see if a package needs data folder(s) created
function handlePackageDataFolder() # $1 is the REAL package name
{
	pushd "$PKG_DIR/$1"
	readPkgDataFile
	instructions=""
	for line in "${g_pkgInfoArray}"
	do
		if [[ "${line:0:5}" == "data=" ]]; then
			line="${line:5}"
			instructions="$line"
			break
		fi
	done
	if [[ "$instructions" == "" ]]; then
		echo "WARNING: No data folder instructions found in the package info"
	fi	
	if [[ "$instructiosn" == "NONE" ]]; then
		return
	fi

	IFS=',' read -r -a folderArray <<< "$instructions"
	for folderName in "${folderArray[@]}"
	do
		if [[ ! -e "$DATA_DIR/$folderName" ]]; then
			echo "Data folder requested, creating $DATA_DIR/$folderName"
			mkdir "$DATA_DIR/$folderName"
		fi
	done
}

#checks _PKG info for install instructions
function getPackageInstallInstructions() # $1 should be real package name
{
	pushd "$PKG_DIR/$1"
	readPkgDataFile
	instructions=""
	for line in "${g_pkgInfoArray}"
	do
		if [[ "${line:0:8}" == "install=" ]]; then
			line="${line:8}"
			instructions="$line"
			break
		fi	
	done
	if [[ "$instructions" == "" ]]; then
		echo "WARNING: No installation instructions found in the package info"
	fi	
	g_pkgInstallInstructions="$instructions"
}

#checks _PKG info for removal instructions
function getPackageRemoveInstructions() # $1 should be real package name
{
	pushd "$PKG_DIR/$1"
	readPkgDataFile
	instructions=""
	for line in "${g_pkgInfoArray}"
	do
		if [[ "${line:0:7}" == "remove=" ]]; then
			line="${line:7}"
			instructions="$line"
			break
		fi	
	done
	if [[ "$instructions" == "" ]]; then
		echo "WARNING: No removal instructions found in the package info"
	fi	
	g_pkgRemoveInstructions="$instructions"
}

# executes single instruction
function carryOutInstruction() # $1 should be the instruction $2 should be package path
{
	# substitue any path variable strings
	instruction="${instruction/\$BIN_DIR/$BIN_DIR}"
	instruction="${instruction/\$PKG_DIR/$PKG_DIR}"
	instruction="${instruction/\$CONF_DIR/$CONF_DIR}"
	instruction="${instruction/\$LIB_DIR/$LIB_DIR}"
	instruction="${instruction/\$DATA_DIR/$DATA_DIR}"

	if [[ "$instruction" == *">"* ]]; then # simple file transfer
		strindex $instruction ">"
		delimiterIndex=$g_workingData
		file="${instruction:0:$delimiterIndex}"
		dest="${instruction:$delimiterIndex+1}"
		cp "$2/$file" "$dest"
	fi
	if [[ "$instruction" == *"~"* ]]; then # create simple script runnable for external
		strindex $instruction "~"
		delimiterIndex=$g_workingData
		runnableName="${instruction:0:$delimiterIndex}"

		instruction="${instruction:$delimiterIndex+1}"
		strindex $instruction "~"
		delimiterIndex=$g_workingData
		runnableThing="${instruction:0:$delimiterIndex}"
		
		runnablePath="${instruction:$delimiterIndex+1}"
		runnableContent="#!/bin/bash\n$runnableThing $@"
		
		echo -e "$runnableContent" > "$runnablePath/$runnableName"
		chmod +x "$runnablePath/$runnableName"
	fi
	if [[ "$instruction" == *"+"* ]]; then # create folder
		strindex $instruction "+"
		delimiterIndex=$g_workingData
		folderName="${instruction:0:$delimiterIndex}"
		folderPath="${instruction:$delimiterIndex+1}"
		mkdir "$folderPath/$folderName"
	fi
	if [[ "$instruction" == *"<"* ]]; then # remove files and/or folders
		strindex $instruction "<"
		delimiterIndex=$g_workingData
		fileName="${instruction:0:$delimiterIndex}"
		filePath="${instruction:$delimiterIndex+1}"

		if [[ "$filePath" == *"<"* ]]; then
			filePath="${filePath:1}"
		fi

		if [[ -d "$filePath/$fileName" ]]; then
			rmdir -rf "$filePath/$fileName"
			return
		fi

		rm "$filePath/$fileName"
	fi
}

function interpretInstructions() # $1 is instruction string, $2 is package path
{
	if [[ "$1" == "NOINSTRUCTIONS" ]]; then
		return
	fi	
	IFS=',' read -r -a instructionArray <<< "$1"
	for instruction in "${instructionArray[@]}"
	do
		carryOutInstruction "$instruction" "$2"
	done
}

# --------------------------- MAIN PROGRAM FLOW ------------------------------

# parse command line arguments
list=false
check=false
update=false
install=false
remove=false
forceDependencies=false
noSpace=false
force=false
override=false
filter=""
otherInfo=""

# note that some arguments require an extra shift in order to store the data that immediately follows
while (( "$#" )); do
	if [[ "$1" == "-install" ]]; then
		shift
		install=true
		otherInfo="$1"
	elif [[ "$1" == "-update" ]]; then
		shift
		update=true
		otherInfo="$1"
	elif [[ "$1" == "-remove" ]]; then
		shift
		remove=true
		otherInfo="$1"
	elif [[ "$1" == "-list" ]]
		list=true
		if [[ "$2" == "installed" ]]; then
			shift
			otherInfo="installed"
		elif [[ "$2" == "update" ]]; then
			shift
			otherInfo="update"
		fi
	elif [[ "$1" == "-forceDependencies" ]]; then
		forceDependencies=true
	elif [[ "$1" == "-noSpace" ]]; then
		noSpace=true
	elif [[ "$1" == "-force" ]]; then
		force=true
	elif [[ "$1" == "-override" ]]; then
		override=false
	elif [[ "$1" == "-filter" ]]; then
		shift
		filter="$1"
	fi

	shift
done


# check that the necessary environemnt variables exist
flag_envVariablesNotSet=false
if [ -z ${BIN_DIR+x} ]; then
	echo "ERROR - Environment variable BIN_DIR not found"
	flag_envVariablesNotSet=true
fi
if [ -z ${DATA_DIR+x} ]; then
	echo "ERROR - Environment variable DATA_DIR not found"
	flag_envVariablesNotSet=true
fi
if [ -z ${LIB_DIR+x} ]; then
	echo "ERROR - Environment variable LIB_DIR not found"
	flag_envVariablesNotSet=true
fi
if [ -z ${CONF_DIR+x} ]; then
	echo "ERROR - Environment variable CONF_DIR not found"
	flag_envVariablesNotSet=true
fi
if [ -z ${PKG_DIR+x} ]; then
	echo "ERROR - Environment variable PKG_DIR not found"
	flag_envVariablesNotSet=true
fi

if $flag_envVariablesNotSet; then
	echo "Necessary environment variables weren't found. Please re-run the setup script that came with the package."
	exit
fi

# shortcuts to important files
LIST_DATA_FILE="$PKG_DIR/labs-get-list/list.dat"
INSTALLED_DATA_FILE="$DATA_DIR/labs-get/installed.dat"
DEFAULT_TAGS_FILE="$DATA_DIR/labs-get/default-tags.dat"
flag_importantFilesNotFound=false

# check for important file existence
if [ ! -e $LIST_DATA_FILE ]; then
	echo "ERROR - Couldn't find $LIST_DATA_FILE" #TODO: ADD COLOR	
	$flag_importantFilesNotFound = true
fi
if [ ! -e $INSTALLED_DATA_FILE ]; then
	echo "ERROR - Couldn't find $INSTALLED_DATA_FILE" #TODO: ADD COLOR	
	$flag_importantFilesNotFound = true
fi
if [ ! -e $DEFAULT_TAGS_FILE ]; then
	echo "ERROR - Couldn't find $DEFAULT_TAGS_FILE" #TODO: ADD COLOR	
	$flag_importantFilesNotFound = true
fi

if $flag_importantFilesNotFound; then
	echo "Necessary data files could not be found. Please re-run the setup script that came with the package."
	exit
fi

readListFile
#g_listDataArray=("${g_workingArray[@]}")

g_filterArray[0]="!lib"

filterPackageListByTags false
g_listDataArray=("${g_workingArray2[@]}")


for i in "${g_listDataArray[@]}"
do
	echo "Yay! $i"
done


